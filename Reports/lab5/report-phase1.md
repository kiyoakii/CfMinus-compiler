# Lab5 实验报告-阶段一

小组成员 姓名 学号

## 实验要求

请按照自己的理解，写明本次实验需要干什么

## 思考题
### LoopSearch

LoopSearch的基本思路是：先找出一个函数的流图的所有极大强连通子集，然后找到这些强连通子集的根作为循环的开始。

删掉之前的根，再找极大强连通子集，作为内循环的根。

一直删、找，直到没有强连通子集为止。

1. 首先要了解Tarjan算法。

   按照深度优先搜索，每个点的index表示访问顺序（一个点只会被访问一次，因此index在被赋值后就不变了），另外还有一个值lowlink，初值等于index。

   lowlink的修改规则是：如果搜索过程中前方的点没有被访问过，则在访问之后，取自己和前方点的lowlink中较小的一个作为自己的lowlink；如果被访问过且和自己在同一个最外层循环中，则取自己的lowlink和前方点的index中较小的一个作为自己的lowlink。

   ![tarjanexample](figs/tarjanexample.jpg)

   上图中每个点的第一个值为index，第二个值为lowlink。首先程序会找到一个环（已经是一个强连通子集了），然后找起点和终点都在已有强连通子集上的路径，加入这个子集。最终，上图会输出两个循环，一个index={2,3,4,5,6,7,8,9,10}，一个index={11,12,13,14}。

   对于一个给定的循环，满足以下两个条件的任意一个的循环内的点就是这个循环的根：这个点的某个父节点不属于循环，或者这个点是一个包含当前循环的大循环的根（已经被删掉了，删掉指删除这个点的所有相邻边）的子节点。

   对于由cminus直接生成的ll程序，每个循环只有一个根，因为cminus中没有跳转指令，从循环外进入循环时，必定先执行循环的第一步。

   如果不考虑cminus的限制，直接观察流图，可以找到如下反例：

   ![oppose](figs/oppose.jpg)

   这个反例中，循环为index={1,2,3}，有1、2两个入口。但事实上cminus的流图不可能像这样，因此程序中不用考虑一个循环有多个根的情况。

2. 循环嵌套有两种情况：

   ![loop_case_1](figs/loop_case_1.jpg)

   第一种是内循环不紧跟外循环的根节点。这里外循环是{0,1,2,3,4}，根是0；删除0号节点后得到内循环是{2,3,4}。

   此时，遍历内循环的所有节点，查找有没有某个节点的某个父节点不属于内循环。2号节点的父节点1号满足条件，所以2号是内循环的根节点。

   ![loop_case_2](figs/loop_case_2.jpg)

   第二种是内循环紧跟外循环的根节点。这里外循环是{0,1,2,3}，根是0；删除0号节点后得到内循环是{1,2,3}。

   此时，遍历内循环的所有节点，查找有没有某个节点的某个父节点不属于内循环，没有找到。

   再看有没有已经被删掉的节点的子节点属于内循环。0号节点的子节点1号满足要求，所以1号是内循环的根节点。

   出现第二种情况的原因是：我们要寻找进入强连通子集的那条边的尾部，作为子集的根（这里直接认为这条边唯一）。但对于内循环，这条边的头部可能连着外循环的根，因此这条边可能已经被删掉了，需要从已被删除的点出发，寻找这条边。

   
### Mem2reg
1. **x** 是 **n** 的支配边界中的元素，当且仅当 **x** 支配 **n** 的一个前驱结点，同时 **x** 并不严格支配 **n**

2. 由于静态赋值只能让变量赋值一次，在遇到有多个前驱的BasicBlock时，可能会出现同一变量有多个版本的问题，phi节点就是为了解决这种问题的(得到确定的版本值)。

   例如：

   ```c
   a = 1;
   if (v < 10)
   	a = 2;
   b = a;
   ```

   此时要想确哪个版本的a给b赋值，就需要添加一个phi node

   ```c
   a1 = 1;
   if (v < 10)
   	a2 = 2;
   b = phi（a1,a2);
   ```

   

3. 

### 代码阅读总结

此次实验有什么收获

### 实验反馈 （可选 不会评分）

对本次实验的建议

### 组间交流 （可选）

本次实验和哪些组（记录组长学号）交流了哪一部分信息
